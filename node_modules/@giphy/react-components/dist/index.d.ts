import { IGif, IUser, GifID, IChannel } from '@giphy/js-types';
import React, { SyntheticEvent, ElementType, PureComponent, ComponentProps, GetDerivedStateFromProps, ReactNode } from 'react';
import * as styled_components from 'styled-components';
import * as styled_components_dist_types from 'styled-components/dist/types';
import { GifsResult, NonPaginatedGifsResult, SearchOptions } from '@giphy/js-fetch-api';
import { debounce } from 'throttle-debounce';
import { PingbackAttributes } from '@giphy/js-analytics';

type Props$9 = {
    gif: IGif;
    className?: string;
    onClick?: (gif: IGif) => void;
};
declare const Attribution: {
    ({ gif, className, onClick }: Props$9): React.JSX.Element | null;
    className: string;
};

type GifOverlayProps = {
    gif: IGif;
    isHovered: boolean;
    onClick?: (gif: IGif) => void;
    width?: number;
    height?: number;
};

type Props$8 = {
    onClick?: (gif: IGif) => void;
};
declare const AttributionOverlay: ({ gif, isHovered, onClick }: GifOverlayProps & Props$8) => React.JSX.Element | null;

type Props$7 = {
    className?: string;
    size?: number;
    fill?: string;
};
declare const VerifiedBadge: {
    ({ className, size, fill }: Props$7): React.JSX.Element;
    className: string;
    checkMarkClassName: string;
};

type EventProps = {
    onGifVisible?: (gif: IGif, e?: SyntheticEvent<HTMLElement, Event>) => void;
    onGifSeen?: (gif: IGif, boundingClientRect: ClientRect | DOMRect) => void;
    onGifClick?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void;
    onGifRightClick?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void;
    onGifKeyPress?: (gif: IGif, e: SyntheticEvent<HTMLElement, Event>) => void;
};
type GifProps = {
    gif: IGif;
    width: number;
    percentWidth?: string;
    height?: number;
    backgroundColor?: string;
    className?: string;
    user?: Partial<IUser>;
    overlay?: ElementType<GifOverlayProps>;
    hideAttribution?: boolean;
    noLink?: boolean;
    borderRadius?: number;
    tabIndex?: number;
    style?: any;
    fetchPriority?: 'auto' | 'high' | 'low';
};
type Props$6 = GifProps & EventProps;
declare const Gif$1: {
    ({ gif, gif: { bottle_data: bottleData }, width, percentWidth, height: forcedHeight, onGifRightClick, className, onGifClick, onGifKeyPress, onGifSeen, onGifVisible, user, backgroundColor, overlay, hideAttribution, noLink, borderRadius, style, tabIndex, }: Props$6): React.JSX.Element;
    className: string;
    imgClassName: string;
    imgLoadedClassName: string;
};

declare const Gif: styled_components.IStyledComponent<"web", styled_components_dist_types.Substitute<{
    gif: IGif;
    width: number;
    percentWidth?: string | undefined;
    height?: number | undefined;
    backgroundColor?: string | undefined;
    className?: string | undefined;
    user?: Partial<IUser> | undefined;
    overlay?: React.ElementType<GifOverlayProps> | undefined;
    hideAttribution?: boolean | undefined;
    noLink?: boolean | undefined;
    borderRadius?: number | undefined;
    tabIndex?: number | undefined;
    style?: any;
    fetchPriority?: "high" | "low" | "auto" | undefined;
} & EventProps, {
    $ml: number;
}>>;
type Props$5 = {
    className?: string;
    user: Partial<IUser>;
    gifHeight: number;
    gifWidth?: number;
    gutter: number;
    fetchGifs: (offset: number) => Promise<GifsResult>;
    onGifsFetched?: (gifs: IGif[]) => void;
    overlay?: ElementType<GifOverlayProps>;
    hideAttribution?: boolean;
    noLink?: boolean;
    noResultsMessage?: string | JSX.Element;
    initialGifs?: IGif[];
    backgroundColor?: string;
    borderRadius?: number;
    tabIndex?: number;
    loaderConfig?: IntersectionObserverInit;
    fetchPriority?: ComponentProps<typeof Gif>[`fetchPriority`];
} & EventProps;
type State$1 = {
    isFetching: boolean;
    gifs: IGif[];
    isLoaderVisible: boolean;
    isDoneFetching: boolean;
};
declare class Carousel extends PureComponent<Props$5, State$1> {
    static className: string;
    static readonly defaultProps: Readonly<{
        gutter: 6;
        user: {};
        initialGifs: never[];
    }>;
    readonly state: {
        gifs: IGif[];
        isFetching: false;
        isLoaderVisible: false;
        isDoneFetching: false;
    };
    el?: HTMLElement;
    unmounted: boolean;
    paginator: () => Promise<IGif[]>;
    componentDidMount(): void;
    componentWillUnmount(): void;
    onLoaderVisible: (isVisible: boolean) => void;
    onFetch: debounce<() => Promise<void>>;
    render(): React.JSX.Element;
}

type EmojiVariationsListProps = {
    backgroundColor?: string;
    dividerColor?: string;
    fetchVariations: (gifId: GifID) => Promise<NonPaginatedGifsResult>;
    gif: IGif;
    gifHeight: number;
    GifProps?: Partial<React.ComponentProps<typeof Gif$1>>;
    gifWidth?: number;
    gutter?: number;
    hideAttribution?: boolean;
    loader?: ElementType;
    noLink?: boolean;
    onVariationsFetched?: (gifs: IGif[]) => void;
    overlay?: ElementType<GifOverlayProps>;
    tabIndex?: number;
    user?: Partial<IUser>;
} & EventProps & React.ComponentProps<'div'>;
declare function EmojiVariationsList(props: EmojiVariationsListProps): React.JSX.Element;
declare namespace EmojiVariationsList {
    var className: string;
    var dividerClassName: string;
    var loaderClassName: string;
    var variationsViewportClassName: string;
    var variationsContainerClassName: string;
}

type Props$4 = {
    className?: string;
    width: number;
    user: Partial<IUser>;
    columns: number;
    gutter: number;
    layoutType?: 'GRID' | 'MIXED';
    fetchGifs: (offset: number) => Promise<GifsResult>;
    onGifsFetched?: (gifs: IGif[]) => void;
    onGifsFetchError?: (e: Error) => void;
    overlay?: ElementType<GifOverlayProps>;
    hideAttribution?: boolean;
    noLink?: boolean;
    noResultsMessage?: string | JSX.Element;
    initialGifs?: IGif[];
    externalGifs?: IGif[];
    useTransform?: boolean;
    columnOffsets?: number[];
    backgroundColor?: string;
    borderRadius?: number;
    tabIndex?: number;
    loaderConfig?: IntersectionObserverInit;
    loader?: ElementType;
    fetchPriority?: ComponentProps<typeof Gif$1>[`fetchPriority`];
} & EventProps;
type State = {
    gifWidth: number;
    isFetching: boolean;
    isError: boolean;
    gifs: IGif[];
    isLoaderVisible: boolean;
    isDoneFetching: boolean;
};
declare class Grid extends PureComponent<Props$4, State> {
    static className: string;
    static loaderClassName: string;
    static fetchDebounce: number;
    static readonly defaultProps: Readonly<{
        gutter: 6;
        user: {};
        initialGifs: never[];
    }>;
    readonly state: {
        gifs: IGif[];
        isFetching: false;
        isError: false;
        gifWidth: 0;
        isLoaderVisible: false;
        isDoneFetching: false;
    };
    bricks?: any;
    el?: HTMLDivElement | null;
    unmounted: boolean;
    paginator: () => Promise<IGif[]>;
    static getDerivedStateFromProps: GetDerivedStateFromProps<Props$4, State>;
    componentDidMount(): void;
    componentWillUnmount(): void;
    onLoaderVisible: (isVisible: boolean) => void;
    onFetch: debounce<() => Promise<void>>;
    render(): React.JSX.Element;
}

declare const Loader: ({ className }: {
    className?: string | undefined;
}) => React.JSX.Element;

type PingbackContextProps = {
    attributes: PingbackAttributes;
    children?: ReactNode;
};
declare const PingbackContext: React.Context<PingbackContextProps>;

type Props$3 = {
    className?: string;
    placeholder?: string;
    clear?: boolean;
    autoFocus?: boolean;
    searchDebounce?: number;
    initialTerm?: string;
    onEnter?: (term: string) => void;
};
declare const SearchBar: {
    ({ className, placeholder, clear, autoFocus, searchDebounce, onEnter, }: Props$3): React.JSX.Element;
    className: string;
};

type SearchContextProps = {
    setSearch: (searchTerm: string) => void;
    term: string;
    activeChannel: IChannel | undefined;
    setChannels: (channels: IChannel[]) => void;
    currentChannels: IChannel[];
    setActiveChannel: (channel: IChannel | undefined) => void;
    fetchGifs: (offset: number) => Promise<GifsResult>;
    fetchAnimatedText: (offset: number) => Promise<GifsResult>;
    fetchChannelSearch: (offset: number) => Promise<IChannel[]>;
    isFetching: boolean;
    trendingSearches: string[];
    searchKey: string;
    isFocused: boolean;
};
declare const SearchContext: React.Context<SearchContextProps>;
type Props$2 = {
    children: ReactNode;
    options?: SearchOptions;
    apiKey: string;
    initialTerm?: string;
    initialChannel?: IChannel;
    shouldDefaultToTrending?: boolean;
    shouldFetchChannels?: boolean;
    theme?: {
        darkMode?: boolean;
        searchbarHeight?: number;
        hideCancelButton?: boolean;
        mobileMediaQuery?: string;
        mobileSearchbarHeight?: number;
    };
};
declare const SearchContextManager: ({ children, options, apiKey, initialTerm, initialChannel, shouldDefaultToTrending, shouldFetchChannels, theme, }: Props$2) => React.JSX.Element;

declare const SuggestionBar: {
    (): React.JSX.Element;
    className: string;
};

type QuartileEvent = 0.25 | 0.5 | 0.75;

type MEDIA_STATE = 'playing' | 'paused';
type IVideo = NonNullable<IGif['video']>;
type Props$1 = {
    onStateChange?: (state: MEDIA_STATE) => void;
    onTimeUpdate?: (playhead: number) => void;
    onError?: (error: number) => void;
    onCanPlay?: () => void;
    onFirstPlay?: (msTillPlay: number) => void;
    onEnded?: () => void;
    onWaiting?: (count: number) => void;
    onLoop?: (count: number) => void;
    onEndFullscreen?: () => void;
    setVideoEl?: (el: HTMLVideoElement) => void;
    onQuartile?: (quartile: QuartileEvent) => void;
    onMuted?: (isMuted: boolean) => void;
    muted?: boolean;
    ccEnabled?: boolean;
    ccLanguage?: keyof NonNullable<IVideo['captions']>;
    loop?: boolean;
    gif: IGif;
    width: number;
    height?: number;
    volume?: number;
    className?: string;
};
declare const Video: {
    ({ muted, ccEnabled, ccLanguage, loop, onStateChange, onTimeUpdate, onCanPlay, onFirstPlay, onWaiting, onMuted, onError, onEnded, onLoop, onQuartile, onEndFullscreen, setVideoEl, gif, width, height: height_, volume, className, }: Props$1): React.JSX.Element | null;
    className: string;
};

type Props = {
    controls?: boolean;
    hideProgressBar?: boolean;
    hideMute?: boolean;
    hideAttribution?: boolean;
    persistentControls?: boolean;
    onUserMuted?: (muted: boolean) => void;
    overlay?: ElementType<GifOverlayProps>;
};
declare const VideoWrapper: (props: ComponentProps<typeof Video> & Props) => React.JSX.Element;

declare const PlayPauseSize = 25;
declare const PlayIcon: ({ size }: {
    size?: number | undefined;
}) => React.JSX.Element;
declare const PauseIcon: ({ size }: {
    size?: number | undefined;
}) => React.JSX.Element;

declare const VolumeSize = 25;
declare const VolumeOnIcon: ({ size, onClick }: {
    size?: number | undefined;
    onClick?: (() => void) | undefined;
}) => React.JSX.Element;
declare const VolumeOffIcon: ({ size, onClick }: {
    size?: number | undefined;
    onClick?: (() => void) | undefined;
}) => React.JSX.Element;

declare const VideoOverlay: {
    ({ gif, isHovered, hideMuteButton, width, height, className, muted: userPrefMuted, onUserMuted, }: GifOverlayProps & {
        width: number;
        height?: number | undefined;
        className?: string | undefined;
        muted?: boolean | undefined;
        hideMuteButton?: boolean | undefined;
        onUserMuted?: ((muted: boolean) => void) | undefined;
    }): React.JSX.Element;
    imgClassName: string;
};

export { Attribution, AttributionOverlay, Carousel, EmojiVariationsList, EmojiVariationsListProps, Gif$1 as Gif, GifOverlayProps, Grid, Loader, PauseIcon, PingbackContext, PlayIcon, PlayPauseSize, SearchBar, SearchContext, SearchContextManager, SuggestionBar, VerifiedBadge, VideoWrapper as Video, VideoOverlay, VolumeOffIcon, VolumeOnIcon, VolumeSize };
